<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Zero - 統合版</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; text-align: center; background: #0a1a0f; color: #e0e0e0; margin: 0; padding: 20px; }
        .container { max-width: 500px; margin: 0 auto; }
        
        h1 { margin-bottom: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

        /* モード切り替えボタン */
        #menu { margin-bottom: 15px; display: flex; justify-content: center; gap: 10px; }
        .mode-btn {
            background: #1f3a26; color: #aaa; border: 1px solid #444;
            padding: 8px 16px; border-radius: 20px; cursor: pointer;
            font-size: 14px; transition: 0.3s;
        }
        .mode-btn.active { 
            background: #4caf50; color: white; border-color: #4caf50; 
            box-shadow: 0 0 10px rgba(76,175,80,0.4); font-weight: bold;
        }

        .info-panel { background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #2e7d32; }
        .status { font-size: 22px; font-weight: bold; color: #4caf50; margin-bottom: 5px; }
        
        #board { 
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
            width: 90vw; max-width: 400px; height: 90vw; max-height: 400px;
            margin: 0 auto; background: #000; border: 6px solid #1b3022; gap: 2px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .cell { background: #1a4d2e; display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer; }
        .cell:nth-child(odd) { background: #1d5534; }
        
        .piece { width: 88%; height: 88%; border-radius: 50%; transition: all 0.2s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        .black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }
        
        .guide { width: 14px; height: 14px; background: rgba(255,255,255,0.15); border-radius: 50%; }
        
        .reset-btn { 
            margin-top: 25px; padding: 10px 30px; font-size: 16px; font-weight: bold; 
            border-radius: 20px; border: none; cursor: pointer; 
            background: #c62828; color: white; box-shadow: 0 4px 0 #8e0000;
        }
        .reset-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #8e0000; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Othello Zero</h1>
        
        <div id="menu">
            <button class="mode-btn active" id="mode1" onclick="setMode(1)">対人戦 (2人)</button>
            <button class="mode-btn" id="mode2" onclick="setMode(2)">VS 究極AI</button>
        </div>

        <div class="info-panel">
            <div class="status" id="msg">対局開始</div>
            <div id="score">黒: 2 / 白: 2</div>
        </div>
        <div id="board"></div>
        <button class="reset-btn" onclick="init()">リセット</button>
    </div>

<script>
    let board = [];
    let turn = 1; 
    let gameMode = 1; // 1:対人, 2:対AI
    let isThinking = false;

    // 究極評価テーブル（ベース）
    const BASE_EVAL = [
        [1000, -150, 30, 10, 10, 30, -150, 1000],
        [-150, -250,  0,  0,  0,  0, -250, -150],
        [  30,    0, 10,  2,  2, 10,    0,   30],
        [  10,    0,  2,  1,  1,  2,    0,   10],
        [  10,    0,  2,  1,  1,  2,    0,   10],
        [  30,    0, 10,  2,  2, 10,    0,   30],
        [-150, -250,  0,  0,  0,  0, -250, -150],
        [1000, -150, 30, 10, 10, 30, -150, 1000]
    ];

    function setMode(m) {
        gameMode = m;
        document.getElementById('mode1').className = m===1 ? 'mode-btn active' : 'mode-btn';
        document.getElementById('mode2').className = m===2 ? 'mode-btn active' : 'mode-btn';
        init();
    }

    function init() {
        board = Array.from({length: 8}, () => Array(8).fill(0));
        board[3][3] = board[4][4] = 2; board[3][4] = board[4][3] = 1;
        turn = 1; isThinking = false;
        draw();
    }

    function draw() {
        const boardElm = document.getElementById('board');
        boardElm.innerHTML = '';
        const moves = getValidMoves(board, turn);

        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                if (board[y][x] === 1) cell.innerHTML = '<div class="piece black"></div>';
                else if (board[y][x] === 2) cell.innerHTML = '<div class="piece white"></div>';
                else if (moves.some(m => m.x === x && m.y === y) && !isThinking) {
                    // 対AIモードでAIの番(turn2)のときはクリックさせない
                    if (!(gameMode === 2 && turn === 2)) {
                        cell.innerHTML = '<div class="guide"></div>';
                        cell.onclick = () => { place(x, y); };
                    }
                }
                boardElm.appendChild(cell);
            }
        }
        updateUI(moves.length);

        // AIのターン処理
        if (gameMode === 2 && turn === 2 && moves.length > 0 && !isThinking) {
            isThinking = true;
            setTimeout(solve, 500); // 思考開始
        }
    }

    function place(x, y) {
        checkFlip(board, x, y, turn, true);
        board[y][x] = turn;
        turn = (turn === 1) ? 2 : 1;
        draw();
    }

    // --- AIロジック（究極版） ---
    function solve() {
        const emptyCells = board.flat().filter(v => v === 0).length;
        const depth = emptyCells <= 12 ? 12 : 6; // 終盤は深く読む
        const result = alphaBeta(board, depth, -Infinity, Infinity, true);
        isThinking = false;
        if (result.move) place(result.move.x, result.move.y);
        else {
            // AIがパスの場合（本来ここには来ないはずだが念のため）
            turn = 1; draw();
        }
    }

    function alphaBeta(vBoard, depth, alpha, beta, isMax) {
        const color = isMax ? 2 : 1;
        const moves = getValidMoves(vBoard, color);
        if (depth === 0 || moves.length === 0) return { score: evaluate(vBoard) };

        // 枝刈り効率化のため良さそうな手から探索
        moves.sort((a, b) => BASE_EVAL[b.y][b.x] - BASE_EVAL[a.y][a.x]);

        let bestMove = null;
        if (isMax) { // AI (白)
            let v = -Infinity;
            for (const m of moves) {
                const next = simulate(vBoard, m.x, m.y, 2);
                const res = alphaBeta(next, depth - 1, alpha, beta, false);
                if (res.score > v) { v = res.score; bestMove = m; }
                alpha = Math.max(alpha, v);
                if (beta <= alpha) break;
            }
            return { score: v, move: bestMove };
        } else { // プレイヤー (黒)
            let v = Infinity;
            for (const m of moves) {
                const next = simulate(vBoard, m.x, m.y, 1);
                const res = alphaBeta(next, depth - 1, alpha, beta, true);
                if (res.score < v) { v = res.score; bestMove = m; }
                beta = Math.min(beta, v);
                if (beta <= alpha) break;
            }
            return { score: v, move: bestMove };
        }
    }

    function evaluate(vBoard) {
        let score = 0;
        const empty = vBoard.flat().filter(v => v === 0).length;
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                if (vBoard[y][x] === 0) continue;
                let val = BASE_EVAL[y][x];
                // 確定石理論: 角が埋まっていればその周辺も安全
                if ((x<=1 && y<=1 && vBoard[0][0]!==0) || (x>=6 && y<=1 && vBoard[0][7]!==0) ||
                    (x<=1 && y>=6 && vBoard[7][0]!==0) || (x>=6 && y>=6 && vBoard[7][7]!==0)) {
                    val = 20; 
                }
                score += (vBoard[y][x] === 2 ? val : -val);
            }
        }
        // 開放度理論: 相手の手数を減らす
        const mobility = (getValidMoves(vBoard, 2).length - getValidMoves(vBoard, 1).length) * (empty > 20 ? 30 : 5);
        return score + mobility;
    }

    function simulate(vBoard, x, y, color) {
        let next = vBoard.map(row => [...row]);
        checkFlip(next, x, y, color, true);
        next[y][x] = color;
        return next;
    }

    // --- 共通ロジック ---
    function getValidMoves(vBoard, color) {
        let res = [];
        for(let y=0; y<8; y++) for(let x=0; x<8; x++) if(checkFlip(vBoard, x, y, color, false) > 0) res.push({x, y});
        return res;
    }

    function checkFlip(vBoard, x, y, color, doFlip) {
        if (vBoard[y][x] !== 0) return 0;
        let total = 0;
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dy, dx] of dirs) {
            let tx = x + dx, ty = y + dy, flipped = [];
            while (ty>=0 && ty<8 && tx>=0 && tx<8 && vBoard[ty][tx] !== 0 && vBoard[ty][tx] !== color) {
                flipped.push([ty, tx]); ty += dy; tx += dx;
            }
            if (ty>=0 && ty<8 && tx>=0 && tx<8 && vBoard[ty][tx] === color && flipped.length > 0) {
                total += flipped.length;
                if (doFlip) flipped.forEach(([py, px]) => vBoard[py][px] = color);
            }
        }
        return total;
    }

    function updateUI(canMove) {
        const b = board.flat().filter(v=>v===1).length;
        const w = board.flat().filter(v=>v===2).length;
        
        // メッセージ生成
        let msgText = "";
        if (canMove === 0) {
            // パスまたは終了
            const nextP = (turn === 1) ? 2 : 1;
            if (getValidMoves(board, nextP).length > 0) {
                msgText = (turn === 1 ? "黒" : "白") + "はパス！";
                turn = nextP; 
                setTimeout(draw, 1000);
            } else {
                msgText = b > w ? "黒の勝ち！" : (w > b ? "白の勝ち！" : "引き分け");
            }
        } else {
            msgText = (turn === 1 ? "黒(あなた)の番" : (gameMode===1 ? "白(相手)の番" : "AI思考中..."));
        }

        document.getElementById('msg').innerText = msgText;
        document.getElementById('score').innerText = `黒: ${b} / 白: ${w}`;
    }

    init();
</script>
</body>
</html>